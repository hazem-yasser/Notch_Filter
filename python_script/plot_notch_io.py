import matplotlib.pyplot as plt
import numpy as np
import csv

# ==============================================================================
# Configuration
# ==============================================================================
FILENAME = "notch_io.txt"
FS = 6.0e6           # 6 MHz (Input and Output are same for Notch)
NORM_FACTOR = 32768.0 # Q1.15 Normalization (32768 = 1.0)

def parse_file(filename):
    """
    Reads the CSV generated by the SystemVerilog Testbench.
    Format: valid_i, data_i, valid_o, data_o
    """
    data_in = []
    data_out = []

    print(f"Reading {filename}...")
    try:
        with open(filename, 'r') as f:
            reader = csv.reader(f, skipinitialspace=True)
            for row in reader:
                if len(row) < 4: continue
                
                v_in  = int(row[0])
                d_in  = int(row[1])
                v_out = int(row[2])
                d_out = int(row[3])
                
                if v_in: data_in.append(d_in)
                if v_out: data_out.append(d_out)

    except FileNotFoundError:
        print(f"Error: Could not find {filename}. Run the simulation first.")
        exit()

    return np.array(data_in), np.array(data_out)

def plot_time_domain(sig_in, sig_out):
    """
    Plots Input and Output signals in time domain with absolute amplitude scaling.
    """
    # Create 2 subplots sharing X axis
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), constrained_layout=True)
    
    # 1. Input Plot
    ax1.plot(sig_in, '.-', color='tab:blue', label=f'Input ({FS/1e6} MHz)')
    ax1.set_title(f"Input Signal (Normalized: 32k = 1.0)")
    ax1.grid(True, alpha=0.3)
    ax1.legend(loc="upper right")
    ax1.set_ylabel("Amplitude")
    ax1.set_ylim([-1.2, 1.2]) 

    # 2. Output Plot
    ax2.plot(sig_out, '.-', color='tab:green', label=f'Output ({FS/1e6} MHz)')
    ax2.set_title(f"Filtered Output (Normalized: 32k = 1.0)")
    ax2.grid(True, alpha=0.3)
    ax2.legend(loc="upper right")
    ax2.set_ylabel("Amplitude")
    ax2.set_xlabel("Sample Index")
    ax2.set_ylim([-1.2, 1.2]) 

    plt.suptitle("Time Domain Analysis (Absolute Scale)", fontsize=16)
    plt.savefig('notch_time_domain.png')

def plot_frequency_domain(sig_in, sig_out):
    """
    Plots FFTs normalized to the Input's peak.
    """
    def get_fft_db(sig, fs):
        # Apply window to reduce spectral leakage
        window = np.hamming(len(sig))
        sig_windowed = sig * window
        
        # Compute FFT
        fft_val = np.fft.fft(sig_windowed)
        fft_freq = np.fft.fftfreq(len(sig), 1/fs)
        
        # Keep positive half
        half_n = len(sig) // 2
        fft_val = fft_val[:half_n]
        fft_freq = fft_freq[:half_n]
        
        # dB Calculation
        mag = 20 * np.log10(np.abs(fft_val) + 1e-12)
        return fft_freq, mag

    # Calculate FFTs
    f_in, mag_in = get_fft_db(sig_in, FS)
    f_out, mag_out = get_fft_db(sig_out, FS)
    
    # Normalize Spectrum Plots to the INPUT's peak (0 dB reference)
    ref_level = np.max(mag_in)

    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), constrained_layout=True)

    # 1. Input Spectrum
    ax1.plot(f_in/1e6, mag_in - ref_level, color='tab:blue')
    ax1.set_title(f"Input Spectrum (0 dB Ref)")
    ax1.set_ylabel("dB")
    ax1.grid(True)
    ax1.set_ylim(bottom=-80, top=5)
    
    # Markers for expected tones
    ax1.axvline(1.0, color='gray', linestyle='--', alpha=0.5, label='1.0 MHz')
    ax1.axvline(2.4, color='gray', linestyle='--', alpha=0.5, label='2.4 MHz')
    ax1.legend(loc='upper right')

    # 2. Output Spectrum
    ax2.plot(f_out/1e6, mag_out - ref_level, color='tab:green')
    ax2.set_title(f"Output Spectrum (Relative to Input)")
    ax2.set_xlabel("Frequency (MHz)")
    ax2.set_ylabel("dB")
    ax2.grid(True)
    ax2.set_ylim(bottom=-80, top=5)

    # Highlight the Notch
    ax2.axvline(2.4, color='red', linestyle='--', label='Notch @ 2.4 MHz')
    ax2.legend(loc='upper right')

    plt.suptitle("Frequency Domain Analysis", fontsize=16)
    plt.savefig('notch_freq_domain.png')

# --- Main Execution ---
if __name__ == "__main__":
    s_in_raw, s_out_raw = parse_file(FILENAME)
    
    print(f"Samples Read -> In: {len(s_in_raw)}, Out: {len(s_out_raw)}")

    if len(s_in_raw) > 0:
        # Match lengths for plotting
        min_len = min(len(s_in_raw), len(s_out_raw))
        s_in_raw = s_in_raw[:min_len]
        s_out_raw = s_out_raw[:min_len]

        print(f"Normalizing by Factor: {NORM_FACTOR}")
        s_in = s_in_raw / NORM_FACTOR
        s_out = s_out_raw / NORM_FACTOR

        # Plot first 300 samples for Time Domain visibility
        plot_time_domain(s_in[:300], s_out[:300]) 
        
        # Plot full signal for Frequency Domain resolution
        plot_frequency_domain(s_in, s_out)
        
        print("Plots saved: 'notch_time_domain.png' and 'notch_freq_domain.png'")
        # plt.show() # Uncomment to view window


